%------------------------------------------------
% Latex-Grundgerüst für Seminarausarbeitungen
%
% zu Erzeugen mit
%   pdflatex ausarbeitung.tex
%
% von Carsten Gutwenger
% angepasst von Igor Vatolkin
%------------------------------------------------

\documentclass[a4paper,12pt,twoside]{article}
\usepackage[a4paper,left=3.5cm,right=2.5cm,bottom=3.5cm,top=3cm]{geometry}

% Encoding der .tex-Datei
% muss je nach Editor-Einstellungen eventuell angepasst werden!
%   latin1    Unix/Windows
%   ansinew   Alternative für Windows
%   applemac  Apple
%   utf8      Alternative für Unix/Windows/Apple
\usepackage[latin1]{inputenc}

\usepackage[ngerman]{babel}                                 % deutsche Sprache
\usepackage[T1]{fontenc}                                    % Unterstützung für Umlaute mit Fonts
\usepackage[pdftex]{graphicx,color}                         % Einbetten von Grafiken, Farbe
\usepackage[format=plain,small,bf,indention=7.5mm]{caption} % verbesserte Beschriftung von Abbildungen
\usepackage{url}                                            % \url{}-Kommando
\usepackage{fancyhdr,float}                                 % Kopf-/Fußzeilen
\usepackage[pdftex,pdfpagelabels]{hyperref}                 % Hyperlinks im PDF
\usepackage{natbib,doi}                                     % Literaturverzeichnis, DOIs
\usepackage[section,boxed]{algorithm}                       % Floating-Umgebung für Algorithmen
\usepackage{algpseudocode}                                  % Pseudocode für Algorithmen

\pagestyle{fancy}
\fancyhead[LE,RO]{\thepage}
\fancyhead[RE]{\nouppercase{\slshape \leftmark}}
\fancyhead[LO]{\nouppercase{\slshape \rightmark}}
\fancyfoot[C]{}


\usepackage{tikz}
\usepackage{csquotes}
\definecolor{hellgruen}{rgb}{0.75,0.75,0.75}
\usepackage{subcaption}
\usepackage{graphicx}
\usepackage{caption}

\begin{document}

%------------------------------------------------
% Titelseite
%------------------------------------------------

\pagenumbering{gobble}
\begin{titlepage}
\vspace*{-2cm}
\newlength{\links}
\setlength{\links}{-1.5cm} \sf \LARGE

\hspace*{\links}
\begin{minipage}{12.5cm}
\includegraphics[width=8cm]{tud_logo_rgb}
\end{minipage}

\vspace*{4cm}

\large
\begin{center}
{\Large Seminarausarbeitung} \\[1ex]
{\LARGE\textbf{Darwin's Avatars}}\\[3ex]
Marian Kleineberg, Christopher Riesner\\[1ex]
\today\\[7ex]
im Rahmen des Proseminars\\[1ex]
{\Large\textbf{Computational Intelligence in Spielen}}\\[1ex]
von Dr.~Igor Vatolkin\\[1ex]
Wintersemester 2016/17
\end{center}

\vspace*{5cm}
\hspace*{\links}
\begin{minipage}[b]{15cm}
\normalsize \raggedright

\textbf{Basierend auf:}\\
D.Lessin, S.Risi, Darwin's Avatars: a Novel Combination of Gameplay and Procedural Content Generation, GECCO '15, July 11 - 16 
\end{minipage}

\definecolor{TUGreen}{rgb}{0.517,0.721,0.094}
\vfill
\hspace*{\links}
\begin{minipage}[b]{8cm}
\normalsize \raggedright
Fakultät für Informatik\\
Lehrstuhl für Algorithm Engineering (Ls11)\\
Technische Universität Dortmund\\
\url{http://ls11-www.cs.tu-dortmund.de}
\end{minipage}

\end{titlepage}

%------------------------------------------------
% Inhaltsverzeichnis
%------------------------------------------------

\tableofcontents
\clearpage


\pagenumbering{arabic}
%------------------------------------------------
% Einführung
%------------------------------------------------

\section{Einführung}

Diese Ausarbeitung \nocite{LeRi15} beschäftigt sich mit dem Spielkonzept von \textsc{Darwin's Avatars}. Der Spieler steuert eine eine Evolutionäre Virtuelle Kreatur, im Folgenden EVK, mit der Tastatur und kann gegen eine KI oder einen weiteren menschlichen Spieler antreten. Das Ziel des Spiels ist, die Kreatur möglichst schnell durch eine Rennstrecke zu bewegen. Damit der Spieler stets für ihn unbekannte Kreaturen kontrollieren kann wird eine Methode verwendet, mit der neue Kreaturen erzeugt werden. Dies wird ermöglicht durch einen evolutionären Algorithmus. Die Vielfalt der daraus resultierenden Kreaturen ermöglicht ein langfristig motivierender Spielspaß.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{img/darwin.png}
	\caption{Screenshot aus \textsc{Darwin's Avatars}. Wer zuerst das Ende der Strecke erreicht, gewinnt \cite{LeRi15}}
\end{figure}


Ein evolutionärer Algorithmus generiert die Kreatur zusammen mit einem neuronalen Netz welches eine automatische Steuerung der Kreatur ermöglicht. Über mehrere hundert Generationen werden die Kreaturen selektiert, die bezüglich des Spielziels am fittesten sind. Durch Paarung oder Mutation werden Kreaturen abgeändert.

In Kapitel \ref{sec:kodierung} wird zunächst dargestellt, wie der Körper einer EVK als Datenstruktur modelliert wird.
Anschließend wird in Kapitel \ref{sec:kontrolle} beschrieben, wie die Kreaturen mit neuronalen Netzen gesteuert werden.
Anschließend werden in Kapitel \ref{sec:evolution} Kreaturen evolutionär generiert.
Einige Ergebnisse dieses Verfahrens werden in \ref{sec:beispiele} vorgestellt.
Kapitel \ref{sec:spiel} beschreibt, wie die bisherigen Techniken zu einem Computerspiel zusammengesetzt werden.
Das Spiel wurde mit Probanden getestet.
Die Testergebnisse werden in Kapitel \ref{sec:ergebnisse} vorgestellt.

\section{Kodierung}
\label{sec:kodierung}

Die EVKs benötigen einen Bauplan der sie spezifiziert. Dieser heißt \textit{Genotyp}. Analog zu dem Begriff aus der Biologie speichert der Genotyp die Daten der Kreatur. 

Die Kreatur ist zusammengesetzt aus Körperteilen, Gelenken und Muskeln.
Die Kreatur wird später in der Physikengine \textsc{PhysX} simuliert.
Aus diesem Grund werden für die Körpersegmente und Gelenke die entsprechenden primitiven Elemente der Physikengine verwendet.
Die möglichen Körpersegmente sind Quader, Ellipsoide und Kapseln.

Wie bei Lebewesen in der Natur brauchen die Körpersegmente Gelenkverbindungen um ihre Struktur beizubehalten.
Dazu werden wieder die von der Physikengine bereitgestellten Optionen verwendet.
So können die Gelenke starr, beugend, verdreht, oder kugelförmig ausfallen.
Ein Parameter für die Gelenkfreiheit bestimmt den Grad bis zu dem sich das Gelenk bewegen lässt.

Die Körpersegmente werden mit Muskeln bespannt, um Bewegungen auszulösen.
In der Physikengine werden diese als Federn modelliert, die an zwei unterschiedlichen Segmenten befestigt sind.
Die Kontraktion der Muskeln wird durch Variation der Federkonstante erreicht.

\begin{figure}
	\begin{subfigure}[b]{0.23\textwidth}
		\centering
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,shorten >=1pt,auto,node distance=0.7cm,main 				  node/.style={circle,draw,font=\sffamily\Large\bfseries}]
			
			\node[main node] (1) {};
			\node[main node] (2) [below left of = 1] {};
			\node[main node] (3) [below right of = 1] {};
			
			\path[every node/.style={font=\sffamily\small}]
			(1) edge [bend right] node[left] {} (2)
			edge [bend left] node[left] {} (3)			
			;
			\end{tikzpicture}	
		}
		\vspace{9.5em}\linebreak			
		\includegraphics[width=\textwidth]{img/1.png}
		\caption{\label{fig:graph1}}
	\end{subfigure}
	~
	\begin{subfigure}[b]{0.23\textwidth}
		\centering
		\resizebox{0.7\textwidth}{!}{
			\begin{tikzpicture}[->,shorten >=1pt,auto,node distance=0.85cm,main node/.style={circle,draw,font=\sffamily\Large\bfseries}]
			
			\node[main node] (1) {};
			\node[main node] (2) [below of = 1] {};
			
			\path[every node/.style={font=\sffamily\small}]
			(1) edge [bend right = 20] node[left] {} (2)
			edge [bend left = 20] node[left] {} (2)			
			;
			\end{tikzpicture}				
		}
		\vspace{8em}\linebreak			
		\includegraphics[width=\textwidth]{img/1.png}
		\caption{\label{fig:graph2}}
	\end{subfigure}
	~
	\begin{subfigure}[b]{0.23\textwidth}
		\centering
		\resizebox{0.9\textwidth}{!}{
			\begin{tikzpicture}[->,shorten >=1pt,auto,node distance=1cm,main node/.style={circle,draw,font=\sffamily\Large\bfseries}]
			
			\node[main node] (1) {};
			\node[main node] (2) [below of = 1] {};
			
			\draw (1) to [out=60,in=120,looseness=8, min distance=0.5cm] (1);
			\draw (2) to [out=300,in=240,looseness=8, min distance=0.5cm] (2);
			
			\path[every node/.style={font=\sffamily\small}]
			(1) edge [bend right = 20] node[left] {} (2)
			edge [bend left = 20] node[left] {} (2)			
			;
			\end{tikzpicture}
		}
		\vspace{1.8em}\linebreak			
		\includegraphics[width=\textwidth]{img/4.png}
		\caption{\label{fig:graph3}}
	\end{subfigure}
	~
	\begin{subfigure}[b]{0.23\textwidth}
		\centering
		\resizebox{0.9\textwidth}{!}{
			\begin{tikzpicture}[->,shorten >=1pt,auto,node distance=0.8cm,main node/.style={circle,draw,font=\sffamily\Large\bfseries}]
			
			\node[main node] (1) {};
			\node[main node] (2) [below of = 1] {};
			\node[main node] (3) [above of = 1] {};
			
			\draw (2) to [out=300,in=240,looseness=8, min distance=0.5cm] (2);
			
			\draw (1) to [] (3);
			
			\path[every node/.style={font=\sffamily\small}]
			(1) edge [bend right = 10] node[left] {} (2)
			edge [bend left = 10] node[left] {} (2)
			edge [bend right = 30] node[left] {} (2)
			edge [bend left = 30] node[left] {} (2)
			;
			\end{tikzpicture}				
		}
		\includegraphics[width=\textwidth]{img/5.png}
		\caption{\label{fig:graph4}}
	\end{subfigure}
	\caption{Der Genotyp als Graph: Die Körpersegmente werden durch Knoten dargestellt. Die Kanten visualisieren die Beziehungen zueinander. \label{fig:genotyp}}
	
\end{figure}

Der Aufbau wird durch einen Graphen beschrieben. In Abbildung \ref{fig:genotyp} sind beispielhaft einige Graphen mit den resultierenden Kreaturen dargestellt.
Jeder Knoten des Graphen repräsentiert einen Prototyp für ein Körpersegment, bestehend aus der Form des Segments und weiteren Eigenschaften wie der Größe.
Die Kanten im Graphen können als Instanziierung eines solchen Prototypen verstanden werden.
Zu jeder Kante gehört ein Gelenktyp und eine Transformation, die beschreibt, wo sich das Körpersegment relativ zum ursprünglichen Segment befindet.
Eine solche Transformation besteht aus einer Translation, einer Rotation und einer Skalierung.

Die Graphen \ref{fig:graph1} und \ref{fig:graph2} führen zur gleichen Kreatur. Das erklärt sich dadurch, dass Graph \ref{fig:graph1} redundante Informationen enthält.
Die Kreatur besteht aus drei Körpersegmenten, aber nur aus zwei verschiedenen Körpersegmenttypen.
Es genügt, für die äußeren Segmente einen gemeinsamen Prototypen zu speichern, der mit den inneren Segment durch zwei Kanten verbunden ist.

Die Graphen \ref{fig:graph3} und \ref{fig:graph4} formen komplexere Kreaturen.
Dazu wird die Eigenschaft reflexiver Kanten ausgenutzt.
Diese Kanten bilden auf instantiieren ihren eigenen Prototypen.
Dadurch entstehen Ketten des gleichen Segments.
Oft ist das eine gewünschte Eigenschaft wie bei den Flügeln der Kreatur \ref{fig:graph3}, oder den Gliedmaßen von Figur \ref{fig:graph4}.
Die reflexiven Kanten können beliebig oft verfolgt werden.
Damit ist eine endlose Rekursion möglich.
Da unendlich große Kreaturen am Computer nicht dargestellt werden können, wird durch das Setzen eines \textit{rekursiven Limits} die Anzahl der Körpersegmente beschränkt. 

Die Kreatur, die aus dem Graphen gebildet wird, heißt \textit{Phänotyp}.

\section{Kontrolle mit neuronalen Netzen}
\label{sec:kontrolle}

Das Ergebnis der Kodierung ist eine Kreatur wie sie im Spiel gesteuert werden kann. Der Genotyp wird jetzt um ein neuronales Netz erweitert.
Künstliche neuronale Netze wurden erstmals von McCulloch und Pitts vorgeschlagen und  werden zur Klassifikation und Synthetisierung von Mustern verwendet \cite{McCulloch1943}.

Das neuronale Netz berechnet Werte zur Steuerung der Kreatur.
Es ist ein Graph, dessen Knoten Neuronen, Sensoren und Effektoren sein können.
Diese Komponenten werden im Folgenden erklärt.

\subsection{Neuronen}

\textit{Neuronen} wenden arithmetische oder logische Operationen auf ein Eingangssignal an und geben es anschließend an ihrem Ausgang zurück. Im Graphen werden die Neuronen als Knoten dargestellt. Sie arbeiten dabei im Wertebereich $[0,1]$.
Mögliche Funktionen sind:

\vspace{0.7em}
\begin{tabular}{l l l l}
	Summe & Produkt & Division & Minimum aus Summe und 1\\
	Größer als & Minimum & Maximum & Wenn dann\\
	Interpolieren & Sinus & Cosinus & Arcus Tangens \\
	Logarithmus & Exponent & Integrieren & Differenzieren \\
	Glätten & Speichern & Sinussignal & Sägezahnsignal
\end{tabular}
\vspace{0.7em}

Wie die Neuronen mit konkreten Werten arbeiten ist in Abbildung \ref{fig:neuronen} ersichtlich. Das Sinus- bzw. Sägezahnsignal errechnet einen vom Zeitparameter $t$ abhängigen Wert. Das Komplement dreht den eingehenden Wert um. Aus $x$ wird $1 - x$. Dieser Parameter wird allerdings nicht als Eingangssignal gegeben, er kommt vom System.

\begin{figure}
	\resizebox{0.24\textwidth}{!}{
		\begin{tikzpicture}[shorten >=1pt,node distance=1.5cm,thick] 
		\node[circle,draw] (1) {wav};
		\coordinate [right of=1] (h1);
		\coordinate [left of=1] (h2);
		\coordinate [above of=h2] (h3);
		\coordinate [below of=h2] (h4);
		\draw [->] (1) to[] node[align=center] {\tiny $\sin(t)$\\} (h1);
		\draw [->, opacity=0] (h2) to[] node[auto] {} (1); 
		\draw [->, opacity=0] (h3) to[] node[auto] {} (1);
		\draw [->, opacity=0] (h4) to[] node[auto] {} (1);			
		\end{tikzpicture}
	}
	\resizebox{0.24\textwidth}{!}{
		\begin{tikzpicture}[shorten >=1pt,node distance=1.5cm,thick] 
		\node[circle,draw] (1) {com};
		\coordinate [right of=1] (h1);
		\coordinate [left of=1] (h2);
		\coordinate [above of=h2] (h3);
		\coordinate [below of=h2] (h4);
		\draw [->] (1) to[] node[align=center] {\tiny 0.147 \\ } (h1);
		\draw [->] (h2) to[] node[auto] {\tiny 0.853} (1);
		\draw [->, opacity=0] (h3) to[] node[auto] {} (1);
		\draw [->, opacity=0] (h4) to[] node[auto] {} (1); 			
		\end{tikzpicture}
	}
	\resizebox{0.24\textwidth}{!}{
		\begin{tikzpicture}[shorten >=1pt,node distance=1.5cm,thick] 
		\node[circle,draw] (1) {max};
		\coordinate [right of=1] (h1);
		\coordinate [left of=1] (h2);
		\coordinate [above of=h2] (h3);
		\coordinate [below of=h2] (h4);
		\draw [->] (1) to[] node[align=center] {\tiny 0.628 \\ } (h1);
		\draw [->] (h2) to[] node[auto] {\tiny 0.628} (1);
		\draw [->] (h3) to[] node[auto] {\tiny 0.254} (1);
		\draw [->, opacity=0] (h4) to[] node[auto] {} (1); 			
		\end{tikzpicture}
	}
	\resizebox{0.24\textwidth}{!}{
		\begin{tikzpicture}[shorten >=1pt,node distance=1.5cm,thick] 
		\node[circle,draw] (1) {+};
		\coordinate [right of=1] (h1);
		\coordinate [left of=1] (h2);
		\coordinate [above of=h2] (h3);
		\coordinate [below of=h2] (h4);
		\draw [->] (1) to[] node[align=center] {\tiny 0.535 \\ } (h1);
		\draw [->] (h2) to[] node[auto] {\tiny 0.1} (1);
		\draw [->] (h3) to[] node[auto] {\tiny 0.435} (1);
		\draw [->] (h4) to[] node[auto] {\tiny 0} (1); 			
		\end{tikzpicture}
	}
	\caption{Neuronen mit verschiedenem Eingangsgrad. Sinus, Komplement, Maximum und das Minimum aus 1 und Summe \label{fig:neuronen}}
\end{figure}

\subsection{Sensoren}

Das Eingangssignal kommt von einem weiteren wesentlichen Bestandteil des neuronalen Netzes, den \textit{Sensoren}. Jeder Muskel einer Kreatur besitzt einen Sensor, der die aktuelle Länge des Muskels misst. Dieser Wert variiert je nachdem, ob er gestreckt, oder zusammengezogen ist. Denkbar wären auch andere Sensoren. Sims \cite{Sims94} erweitert die Kreaturen um Photosensoren, die es der Kreatur ermöglichen, sich auf eine Lichtquelle zu zubewegen. Auch Kontaktsensoren bieten sich an. In dem Spiel wird sich auf Sensoren beschränkt, die die Länge des Muskels messen.

\subsection{Effektoren}

Die Neuronen berechnen in Abhängigkeit von der Länge der Muskeln einen Wert. Dieser Wert landet bei den \textit{Effektoren}. Wie auch die Sensoren gehören die Effektoren zu den Muskeln. Die Effektoren spannen in Abhängigkeit vom berechneten Wert den Muskel an, oder entspannen ihn. Durch diesen Kreislauf wird der Kreatur eine flüssige Bewegung ermöglicht. Die Sensoren und die Effektoren werden im Genotyp wie die Neuronen als Knoten dargestellt.

\subsection{Grapherweiterung}

Mit den Bestandteilen ist das neuronale Netz komplett und es lässt sich zusammengefügt im Genotyp einsetzen. Abbildung  \ref{fig:extendedgraph} zeigt einen solchen Genotypen. Die fett gezeichneten Knoten beschreiben wie in den vorherigen Beispielen die Körpersegmente. J0 und J1 generieren je einen Wert, der durch verschiedene Neuronen reist und zum Schluss in den Effektoren ankommt. Neben den fett gezeichneten Knoten gibt es im Genotypen auch einen durch eine gestrichelte Linie markierten Knoten. Dieser enthält Neuronen die für die Kreatur genau ein einziges Mal zur Kontrolle benötigt werden. Der Knoten ist unabhängig vom gewählten Parameter des rekursiven Limits. Die Sensoren und Effektoren der Muskeln sind zudem nur in einem Segment eingetragen, obwohl sie zwei Körpersegmente verbinden. Sie dienen im Graph jedoch nur als Quelle und Ziel eines Signals, es ist nicht notwendig sie doppelt aufzuführen. Das rekursive Limit der Kreatur wird auf $2$ gesetzt und als Gelenk zwischen den beiden mittleren Segmenten wird ein verdrehtes Gelenk gewählt, für die äußeren Segmente hingegen ein beugendes. Mit der Wahl dieser Parameter entsteht die Kreatur, die in Abbildung \ref{fig:extendedgraph} gezeigt wird. Die Kreatur kann die beiden Mittelsegmente drehen und bewegt sich durch Flügelschwung.

\begin{figure}[H]
	\resizebox{0.55\textwidth}{!}{
	\includegraphics[width=0.9\textwidth]{img/evolved_graph.png}
	}
	\resizebox{0.45\textwidth}{!}{
	\includegraphics[width=0.9\textwidth]{img/6.png}
	}
	\caption{Genotyp \cite{Sims94} mit Sensoren J0, J1 und Effektoren E0, E1 und der zugehörige Phänotyp \label{fig:extendedgraph}}
\end{figure}

\section{Evolutionäre Generierung}
\label{sec:evolution}

EVKs werden mithilfe eines evolutionären Algorithmus generiert.
Bei einem evolutionären Algorithmus werden nach dem Vorbild der Evolution in der Natur Entitäten, in diesem Fall EVKs, bezüglich einer Fitnessfunktion optimiert.
Der hier vorgestellte Algorithmus gehört zu den \textit{genetischen Algorithmen}, einer Unterklasse der evolutionären Algorithmen.
Genetische Algorithmen zeichnen sich dadurch aus, dass sie zwischen Genotyp und Phänotyp unterscheiden.
Sie wurden erstmalig von Holland vorgeschlagen \cite{Holland1992}.

Das Verfahren soll Entitäten von besonders hoher Fitness produzieren.
In \textsc{Darwin's Avatars} ist die Fitness die Laufgeschwindigkeit der Kreaturen.
Dabei ist besonders wichtig, dass die Fitnessfunktion mit dem Spielziel übereinstimmt.
Zusätzlich zur Laufgeschwindigkeit werden für die Fitness ästhetische Eigenschaften berücksichtigt. 

Die Generierung von EVKs wird bei Lessin, Fussel und Miikkulainen \cite{LeFuMi13} im Detail beschrieben und basiert auf der Arbeit von Sims \cite{Sims94}.

\subsection{Evolutionärer Algorithmus}
Zunächst wird ein eine Population von zufälligen Kreaturen generiert.
Alle Eigenschaften der Kreaturen werden zufällig gesetzt, dazu gehören der Graph der Körperteile, die Muskeln und das neuronale Netz.
Die in der Arbeit verwendete Populationsgröße ist $100$.

Nun wird in jeder Generation der Fitnesswert für jede Kreatur bestimmt.
Dazu wird die Kreatur in der Physikengine \textsc{PhysX} simuliert und die Laufgeschwindigkeit gemessen.
Dieser Teil des Verfahrens ist besonders rechenaufwändig.
Ein Teil der Population, $80\%$, wird verworfen.
Die Population wird mit Mutationen und Nachkommen der verbleibenden Kreaturen auf ihre ursprüngliche Größe aufgefüllt.

Dieser Schritt wird je nach verfügbarer Rechenzeit solange wiederholt, bis die Fitness der besten Kreaturen gut genug ist.
In dieser Arbeit werden $500$ Generationen berechnet.

\subsection{Mutation}
Die Mutation ist die zufällige Veränderung einer bestehenden Kreatur.
Das Verfahren ist ähnlich zu der zufälligen Generierung einer neuen Kreatur, allerdings werden Werte bevorzugt, die nahe an denen der bestehenden Kreatur sind.
Eine zufällige Auswahl der Eigenschaften der Kreatur wird geändert.
Abhängig des Datentyps wird mit den Eigenschaften wie folgt verfahren:
Booleans werden negiert. Kontinuierliche Werte werden zufällig verschoben. Der Wert der Änderung ist dabei Gauß-verteilt, kleine Änderungen sind häufiger als große.
Diskrete Werte werden zufällig neu gesetzt.
Im neuronalen Netz und im Graphen der Körperteile werden Knoten und Kanten zufällig hinzugefügt und entfernt.

\subsection{Paarung}
Bei der Paarung werden zur Generierung einer neuen Kreatur zwei bestehende Kreaturen, die Eltern, berücksichtigt.
Im Folgenden werden zwei Verfahren zur Paarung beschrieben, die in \textsc{Darwin's Avatars} Verwendung finden.

In beiden Fällen wird der Graph der Kreatur zunächst in eine lineare Form gebracht.
Die Menge Knoten wird als Liste aufgefasst.
Die Ziele der Kanten werden durch ihre relative Position gespeichert.
Eine Kante mit dem Wert $+2$ zeigt auf den Knoten, der in der Liste der zweite Nachfolger des Ausgangsknotens ist.

\begin{figure}
	\begin{center}
		\resizebox{0.48\textwidth}{!}{
			\begin{tikzpicture}[->,shorten >=1pt,auto,node distance=0.8cm,main node/.style={circle,draw,font=\sffamily\Large\bfseries}]
			
			\node[main node] (1) {};
			\node[main node] (2) [right of = 1] {};
			\node[main node] (3) [right of = 2] {};
			\node[main node] (4) [right of = 3] {};
			\node[main node] (5) [right of = 4] {};
			
			\path[] (1) edge [bend left = 40] node[left] {} (2);
			\path[] (1) edge [bend left = 80] node[left] {} (3);
			\path[] (3) edge [bend left = 30] node[left] {} (4);
			\path[] (3) edge [bend left = 60] node[left] {} (4);
			\path[] (4) edge [bend left = 40] node[left] {} (5);
			
			\end{tikzpicture}
		}
		\hspace{1em}
		\resizebox{0.38\textwidth}{!}{
			\begin{tikzpicture}[->,shorten >=1pt,auto,node distance=0.8cm,main node/.style={circle,draw,font=\sffamily\Large\bfseries}]
			
			\node[main node] (1) [fill = hellgruen] {};
			\node[main node] (2) [right of = 1, fill = hellgruen] {};
			\node[main node] (3) [right of = 2, fill = hellgruen] {};
			\node[main node] (4) [right of = 3, fill = hellgruen] {};
			
			\path[] (1) edge [bend left = 10] node[left] {} (2);
			\path[] (1) edge [bend left = 30] node[left] {} (2);
			\path[] (1) edge [bend left = 50] node[left] {} (2);
			\path[] (1) edge [bend left = 50] node[left] {} (2);
			\path[] (2) edge [bend left = 30] node[left] {} (3);
			\path[] (2) edge [bend left = 60] node[left] {} (4);
			
			\draw (4) to [out=110,in=70,looseness=8] (4);
			
			\end{tikzpicture}
		}
	\end{center}		
	\begin{center}
		\includegraphics[width=0.9\textwidth]{img/pfeile.png}
	\end{center}	
	\resizebox{0.46\textwidth}{!}{
		\begin{tikzpicture}[->,shorten >=1pt,auto,node distance=0.8cm,main node/.style={circle,draw,font=\sffamily\tiny\bfseries}]
		
		\node[main node] (1) {};
		\node[main node] (2) [right of = 1, fill = hellgruen] {};
		\node[main node] (3) [right of = 2] {};
		\node[main node] (4) [right of = 3, fill = hellgruen] {};
		\node[main node] (5) [right of = 4] {};
		
		\path[] (1) edge [bend left = 40] node[left] {} (2);
		\path[] (1) edge [bend left = 80] node[left] {} (3);
		\path[] (3) edge [bend left = 30] node[left] {} (4);
		\path[] (3) edge [bend left = 60] node[left] {} (4);
		
		\path[] (2) edge [bend left = 30] node[left] {} (3);
		\path[] (2) edge [bend left = 60] node[left] {} (4);
		
		\draw (4) to [out=110,in=70,looseness=8] (4);
		
		\end{tikzpicture}
	}

	\caption{Paarung durch \enquote{Kreuzung}: Der erste Elternteil wird kopiert und einzelne Knoten werden durch die Knoten des anderen Elternteils an der gleichen Position ersetzt. \label{paarung1}}
\end{figure}

Abbildung \ref{paarung1} zeigt die erste Methode zur Paarung, die \textit{Kreuzung}.
Zunächst wird eine Kopie des einen Elternteils angelegt.
Nun wird eine zufällige Auswahl an Knoten, im Beispiel Knoten 2 und 4, durch die Knoten mit der gleichen Position des anderen Elternteils ersetzt.
Die neuen Knoten behalten ihre Kanten mit den relativen Werten, die jetzt aber ggf. auf einen anderen Knoten der gleichen relativen Position zeigen.

\begin{figure}
	\resizebox{0.48\textwidth}{!}{
		\begin{tikzpicture}[->,shorten >=1pt,auto,node distance=0.8cm,main node/.style={circle,draw,font=\sffamily\Large\bfseries}]
		
		\node[main node] (1) {};
		\node[main node] (2) [right of = 1] {};
		\node[main node] (3) [right of = 2] {};
		\node[main node] (4) [right of = 3] {};
		\node[main node] (5) [right of = 4] {};
		
		\path[] (1) edge [bend left = 40] node[left] {} (2);
		\path[] (1) edge [bend left = 80] node[left] {} (3);
		\path[] (3) edge [bend left = 30] node[left] {} (4);
		\path[] (3) edge [bend left = 60] node[left] {} (4);
		\path[] (4) edge [bend left = 40] node[left] {} (5);
		
		\end{tikzpicture}
	}
	\hspace{2.5em}
	\resizebox{0.38\textwidth}{!}{
		\begin{tikzpicture}[->,shorten >=1pt,auto,node distance=0.8cm,main node/.style={circle,draw,font=\sffamily\Large\bfseries}]
		
		\node[main node] (1) [fill = hellgruen] {};
		\node[main node] (2) [right of = 1, fill = hellgruen] {};
		\node[main node] (3) [right of = 2, fill = hellgruen] {};
		\node[main node] (4) [right of = 3, fill = hellgruen] {};
		
		\path[] (1) edge [bend left = 10] node[left] {} (2);
		\path[] (1) edge [bend left = 30] node[left] {} (2);
		\path[] (1) edge [bend left = 50] node[left] {} (2);
		\path[] (1) edge [bend left = 50] node[left] {} (2);
		\path[] (2) edge [bend left = 30] node[left] {} (3);
		\path[] (2) edge [bend left = 60] node[left] {} (4);
		
		\draw (4) to [out=110,in=70,looseness=8] (4);				
		\end{tikzpicture}
	}

	\begin{center}
	\includegraphics[width=0.7\textwidth]{img/pfeile2.png}
	\end{center}
	
	\begin{center}
	\resizebox{0.8\textwidth}{!}{
		\begin{tikzpicture}[->,shorten >=1pt,auto,node distance=0.8cm,main node/.style={circle,draw,font=\sffamily\tiny\bfseries}]
		
		\node[main node] (1) {};
		\node[main node] (2) [right of = 1] {};
		\node[main node] (3) [right of = 2] {};
		\node[main node] (4) [right of = 3] {};
		\node[main node] at (4, 0) (7) [fill = hellgruen] {};
		\node[main node] (8) [right of = 7, fill = hellgruen] {};
		\node[main node] (9) [right of = 8, fill = hellgruen] {};
		
		\path[] (1) edge [bend left = 40] node[left] {} (2);
		\path[] (1) edge [bend left = 80] node[left] {} (3);
		\path[] (3) edge [bend left = 30] node[left] {} (4);
		\path[] (3) edge [bend left = 60] node[left] {} (8);
		\path[] (7) edge [bend left = 30] node[left] {} (8);
		\path[] (7) edge [bend left = 60] node[left] {} (9);
		
		\draw (4) to [out=110,in=70,looseness=8] (4);				
		\end{tikzpicture}
	}
	\end{center}

	
	\caption{Paarung durch \enquote{Veredelung}: Teilketten beider Elternteile werden konkateniert und mit einer Kante verbunden. \label{paarung2}}
\end{figure}

Abbildung \ref{paarung2} zeigt die zweite Methode zur Paarung, die \textit{Veredelung}.
Es werden von beiden Elternteil Teilketten gebildet, ein Präfix vom ersten Elternteil und ein Suffix vom zweiten.
Diese beiden Teilketten werden konkateniert.
Eine bestehende Kante der linken Teilkette wird so abgeändert, dass sie auf einen Knoten der rechten Teilkette zeigt.

Im Anschluss werden bei beiden Verfahren unerreichbare Knoten gelöscht. Kanten, die nach der Paarung auf Knoten außerhalb der Liste zeigen, werden zufällig neu gesetzt.

\subsection{Evolution in der Praxis}
Die Bestimmung der Fitnesswerte der Kreaturen in jeder Generation benötigt für jede Berechnung eine Physiksimulation der Kreatur.
Diese Simulation ist sehr rechenaufwändig und ist für lange Rechenzeiten zur Berechnung einer einzelnen Kreatur verantwortlich.
Da die Fitnesswerte innerhalb einer Generation unabhängig voneinander sind, können sie parallel berechnet werden.
Bei besonders schlechter Fitness wird die Berechnung vorzeitig abgebrochen, um Rechenzeit zu sparen.

Rundungsfehler und Bugs in der Physikengine werden von dem evolutionären Algorithmus gefunden und ausgenutzt.
Das muss verhindert werden, da sonst Lösungen entstehen, die zwar gute Ergebnisse liefern, aber unrealistisch erscheinen und keine guten Spielgegenstände darstellen.
Das gleiche gilt für Triviallösungen, wie Fortbewegung durch Umfallen.

\section{Beispiele}
\label{sec:beispiele}
Im Folgenden werden drei Beispiele von EVKs dargestellt, die mit dem zuvor beschriebenen Verfahren entwickelt wurden.
Die Kreaturen sind in Abbildung \ref{fig:beispiele} dargestellt.

\renewcommand\thesubfigure{\Alph{subfigure}}
\begin{figure}[H]
	\centering
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{img/type1.png}
		\caption{\label{fig:bsp1}}		
	\end{subfigure}
	~
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{img/type2.png}
		\caption{\label{fig:bsp2}}		
	\end{subfigure}
	~
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{img/type3.png}
		\caption{\label{fig:bsp3}}		
	\end{subfigure}
	\caption{Drei Evolutionäre Virtuelle Kreaturen \cite{LeRi15} \label{fig:beispiele}}
\end{figure}

Die erste Kreatur \ref{fig:bsp1} besteht aus zwei Gliedmaßen und drei Muskeln.
Sie kann durch Anheben des vorderen, schwereren Blocks lange Sprünge ausführen.

Die zweite Kreatur \ref{fig:bsp2} besteht aus drei Gliedmaßen und vier Muskeln.
Aufgrund der Symmetrie besteht die Gefahr, dass die Kreatur sich rückwärts bewegt, da die Bewegung in beide Richtungen für den Mensch oder den Rechner gleich schwierig ist.
Die Kreatur springt vorwärts indem sie die beiden seitlichen Gliedmaßen anhebt.
Außerdem besteht die Gefahr des Umfallens.

Die dritte Kreatur \ref{fig:bsp3} besteht aus sieben Gliedmaßen und sechs Muskeln.
Sie führt eine langsame, vierbeinige Fortbewegung aus.

\section{Spielmechanik}
\label{sec:spiel}
Im Spiel treten zwei Kopien der gleichen, im Vorfeld berechneten, EVK an.
Eine Kopie wird durch das evolutionär generierte neuronale Netz gesteuert.
Die andere Kopie wird durch den menschlichen Spieler gesteuert.
Beide Kreaturen versuchen, möglichst schnell das Ziel zu erreichen.
Das Spiel ist beendet, wenn beide Kreaturen das Ziel erreicht haben oder ein Zeitlimit abgelaufen ist.

Der Mensch steuert seine Kreatur mit der Tastatur.
Dabei ist jeder Muskel mit einer Taste verbunden.
Im Gegensatz zum neuronalen Netz, das den Muskel kontinuierlich steuern kann, können Muskeln durch die Tastatur nur gar nicht oder vollständig aktiviert sein.
Dies stellt einen Vorteil für den Computergegner dar, da diesem so eine genauere Kontrolle möglich ist.

\section{Testergebnisse}
\label{sec:ergebnisse}
Für jede der bereits vorgestellten Kreatur wurden nun die erreichten Geschwindigkeiten der Spieler und der KI gemessen.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.49\textwidth]{img/ki1.png}
	\centering
	\begin{subfigure}[b]{0.49\textwidth}
		\centering
		\includegraphics[width=\textwidth]{img/hum11.png}
	\end{subfigure}
	\begin{subfigure}[b]{0.49\textwidth}
		\centering
		\includegraphics[width=\textwidth]{img/hum12.png}
	\end{subfigure}
	\begin{subfigure}[b]{0.49\textwidth}
		\centering
		\includegraphics[width=\textwidth]{img/hum13.png}
	\end{subfigure}
	\begin{subfigure}[b]{0.49\textwidth}
		\centering
		\includegraphics[width=\textwidth]{img/hum14.png}
	\end{subfigure}
	\begin{subfigure}[b]{0.49\textwidth}
		\centering
		\includegraphics[width=\textwidth]{img/hum15.png}
	\end{subfigure}
	\begin{subfigure}[b]{0.49\textwidth}
		\centering
		\includegraphics[width=\textwidth]{img/hum16.png}
	\end{subfigure}
	\caption{Testergebnisse für Beispiel A \cite{LeRi15} \label{fig:test1}}
\end{figure}

Die Diagramme in Abbildung \ref{fig:test1} zeigen den Grad der Aktivierung der Muskeln in Abhängigkeit der Zeit.
Menschliche Spieler sind in grün dargestellt, das evolutionär generierte neuronale Netz ist in rot dargestellt.
Die erreichte Geschwindigkeit findet sich oberhalb des Diagramms.
Die KI verwendete zur Fortbewegung eine simple Strategie. Sie benutze lediglich die Muskeln 0 und 1 abwechselnd mit konstanter Frequenz. Damit erreichte sie die größte Geschwindigkeit. Die menschlichen Spieler nutzten eine ähnliche Strategie, jedoch weniger erfolgreich, da ihre Frequenz nicht konstant war. Die Spieler 5 und 6 verwendeten als einzige auch den Muskel 2.

\begin{figure}[H]
	\centering
	\begin{subfigure}[b]{\textwidth}
		\centering
		\includegraphics[width=0.49\textwidth]{img/ki2.png}
	\end{subfigure}
	\begin{subfigure}[b]{0.49\textwidth}
		\centering
		\includegraphics[width=\textwidth]{img/hum21.png}
	\end{subfigure}
	\begin{subfigure}[b]{0.49\textwidth}
		\centering
		\includegraphics[width=\textwidth]{img/hum22.png}
	\end{subfigure}
	\begin{subfigure}[b]{0.49\textwidth}
		\centering
		\includegraphics[width=\textwidth]{img/hum23.png}
	\end{subfigure}
	\begin{subfigure}[b]{0.49\textwidth}
		\centering
		\includegraphics[width=\textwidth]{img/hum24.png}
	\end{subfigure}
	\begin{subfigure}[b]{0.49\textwidth}
		\centering
		\includegraphics[width=\textwidth]{img/hum25.png}
	\end{subfigure}
	\begin{subfigure}[b]{0.49\textwidth}
		\centering
		\includegraphics[width=\textwidth]{img/hum26.png}
	\end{subfigure}
	\caption{Testergebnisse für Beispiel B \cite{LeRi15}\label{fig:test2}}
\end{figure}

Beim Beispiel B macht sich der entscheidende Vorteil der KI bemerkbar. Sie kann die Muskeln in verschiedenen Intensitäten kontrahieren. Dies führt zu erheblich besseren Ergebnissen als die der menschlichen Spieler. Bei dieser komplexeren Kreatur verwendeten die Spieler allesamt verschiedene Strategien. Spieler 4 hat mit der einfachsten Strategie der menschlichen Spieler die beste Geschwindigkeit erreicht.

\begin{figure}[H]
	\centering
	\begin{subfigure}[b]{\textwidth}
		\centering
		\includegraphics[width=0.49\textwidth]{img/ki3.png}
	\end{subfigure}
	\begin{subfigure}[b]{0.49\textwidth}
		\centering
		\includegraphics[width=\textwidth]{img/hum31.png}
	\end{subfigure}
	\begin{subfigure}[b]{0.49\textwidth}
		\centering
		\includegraphics[width=\textwidth]{img/hum32.png}
	\end{subfigure}
	\begin{subfigure}[b]{0.49\textwidth}
		\centering
		\includegraphics[width=\textwidth]{img/hum33.png}
	\end{subfigure}
	\begin{subfigure}[b]{0.49\textwidth}
		\centering
		\includegraphics[width=\textwidth]{img/hum34.png}
	\end{subfigure}
	\begin{subfigure}[b]{0.49\textwidth}
		\centering
		\includegraphics[width=\textwidth]{img/hum35.png}
	\end{subfigure}
	\begin{subfigure}[b]{0.49\textwidth}
		\centering
		\includegraphics[width=\textwidth]{img/hum36.png}
	\end{subfigure}
	\caption{Testergebnisse für Beispiel C \cite{LeRi15}\label{fig:test3}}
\end{figure}

Erstmals schafft ein menschlicher Spieler mit der dritten Kreatur die KI zu schlagen. Erneut macht sich die KI zunutze, dass sie die Muskeln verschieden stark aktivieren kann. Das simple Wechseln zwischen den Muskeln 4 und 5 und den beiden Muskeln 1 und 2 erzielte bessere Ergebnisse. Auch andere Spieler konnten mit dem Ergebnis der KI mithalten. Es wird jedoch auch deutlich, dass mit steigender Komplexität keine so hohe  Geschwindigkeiten erzielt werden.

\subsection{Analyse}

Die folgenden Diagramme fassen die Testergebnisse der einzelnen Kreaturen zusammen. Die Ergebnisse stammen aus 5 Durchläufen. Bei allen drei Beispielen verfolgte die KI über alle Durchläufe die gleiche Strategie. Das erklärt die konstanten Kurven im Diagramm. Die Kurven der menschlichen Spieler steigen tendenziell mit den späteren Durchläufen. Es zeigt sich eine Lernkurve. Wie schon bei den anderen Diagrammen erkennbar, erreichen die menschlichen Spieler im Normalfall nicht die Geschwindigkeit der KI. Eine Ausnahme bei der Kreatur C ist sichtbar in den Durchläufen 2 und 5.

\begin{figure}	
	\centering
	\includegraphics[width=0.78\textwidth]{img/Comparison_A.png}
	\caption{Vergleichschart zu Beispiel A \cite{LeRi15}\label{fig:comp1}}
\end{figure}
\begin{figure}
	\centering
	\includegraphics[width=0.78\textwidth]{img/Comparison_B.png}
	\caption{Vergleichschart zu Beispiel B \cite{LeRi15}\label{fig:comp2}}		
\end{figure}
\begin{figure}
	\centering
	\includegraphics[width=0.78\textwidth]{img/Comparison_C.png}
	\caption{Vergleichschart zu Beispiel C \cite{LeRi15}\label{fig:comp3}}	
\end{figure}

\section{Weiterführende Betrachtungen}
Zur Schaffung einer KI der generierten Kreaturen wird ein evolutionärer Algorithmus verwendet. Alternativ eignet sich dafür der Monte Carlo Tree Search, der an Stelle eines neuronalen Netzes aufgrund der effizienteren Datenstruktur oft zur Berechnung von Zügen einer KI gewählt wird (vgl. \cite{MaWi15}). Da dieses Spiel jedoch eine Bewegung in Echtzeit realisieren möchte, eignen sich keine Verfahren die Züge innerhalb von Runden berechnen.  

Einen weiteren interessanten Ansatz zur prozeduralen Generierung findet man im Pflanzenzuchtspiel \textsc{Petalz} \cite{RiLe15}. Dabei handelt es sich um ein Social Game, welche beispielsweise in Facebook gefunden werden können. Ähnlich wie in \textsc{Darwin's Avatars} werden die Inhalte prozedural generiert. Die Blumen sind einzigartig und bieten viele Anpassungsmöglichkeiten. Sie werden durch neuronale Netzwerke generiert, die sich in ihren Funktionen unterscheiden.


\section{Zusammenfassung}
In \textsc{Darwin's Avatars} werden Spielgegenstände prozedural generiert.
Dazu wird zunächst eine Kreatur, bestehend aus Gliedmaßen, Muskeln und Gehirn, evolutionär entwickelt, um möglichst geeignet für das Erreichen des Spielziels zu sein.
Anschließend wird das Gehirn der Kreatur durch die Kontrolle des Spielers ersetzt.
Die Testergebnisse in Kapitel \ref{sec:ergebnisse} zeigen, dass sich so ein tragfähiges Spielkonzept ergibt und die EVKs interessante Spielgegenstände darstellen.
Ein weiteres Ergebnis der Tests ist, dass Menschen den evolutionären Gehirnen generell unterlegen sind.
Ein Nachteil des evolutionären Vorgehens ist die hohe Rechenleistung, die zur Generierung einer einzelnen Kreatur nötig ist.
So ist nicht praktikabel, die Kreaturen während des Spiels auf dem Rechner des Spielers zu generieren.

Das Spielkonzept ist in verschiedener Hinsicht erweiterbar.
Bei Sims werden neben der Fortbewegung weitere Aktivitäten beschrieben, auf die virtuelle Kreaturen trainiert werden können \cite{Sims94}.
Diese Aktivitäten lassen sich direkt in entsprechende Spielmodi übertragen.
Dazu gehören Springen, Schwimmen, Klettern und Kämpfen.
Abgesehen davon nennt Lessin als mögliche Spielmechanik das Sammeln und Tauschen von Kreaturen und Online-Multiplayer.
Eine weitere mögliche Abwandlung wäre die Beschränkung des evolutionären Gehirns auf binäre Muskelsteuerung.
So hätte der Computergegner die gleichen Voraussetzungen wie der Mensch.



%------------------------------------------------
%Beispiel für Referenzen: \cite{HanKno06} (Zeitschriftenartikel) und \cite{TarekEtAl07} (Konferenzartikel).
%------------------------------------------------

%------------------------------------------------
% Literaturverzeichnis
%------------------------------------------------

\bibliographystyle{plain}
\bibliography{literatur}
\addcontentsline{toc}{section}{\bibname}


\end{document}
