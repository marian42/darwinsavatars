%------------------------------------------------
% Latex-Grundgerüst für Seminarausarbeitungen
%
% zu Erzeugen mit
%   pdflatex ausarbeitung.tex
%
% von Carsten Gutwenger
% angepasst von Igor Vatolkin
%------------------------------------------------

\documentclass[a4paper,12pt,twoside]{article}
\usepackage[a4paper,left=3.5cm,right=2.5cm,bottom=3.5cm,top=3cm]{geometry}

% Encoding der .tex-Datei
% muss je nach Editor-Einstellungen eventuell angepasst werden!
%   latin1    Unix/Windows
%   ansinew   Alternative für Windows
%   applemac  Apple
%   utf8      Alternative für Unix/Windows/Apple
\usepackage[latin1]{inputenc}

\usepackage[ngerman]{babel}                                 % deutsche Sprache
\usepackage[T1]{fontenc}                                    % Unterstützung für Umlaute mit Fonts
\usepackage[pdftex]{graphicx,color}                         % Einbetten von Grafiken, Farbe
\usepackage[format=plain,small,bf,indention=7.5mm]{caption} % verbesserte Beschriftung von Abbildungen
\usepackage{url}                                            % \url{}-Kommando
\usepackage{fancyhdr,float}                                 % Kopf-/Fußzeilen
\usepackage[pdftex,pdfpagelabels]{hyperref}                 % Hyperlinks im PDF
\usepackage{natbib,doi}                                     % Literaturverzeichnis, DOIs
\usepackage[section,boxed]{algorithm}                       % Floating-Umgebung für Algorithmen
\usepackage{algpseudocode}                                  % Pseudocode für Algorithmen

\pagestyle{fancy}
\fancyhead[LE,RO]{\thepage}
\fancyhead[RE]{\nouppercase{\slshape \leftmark}}
\fancyhead[LO]{\nouppercase{\slshape \rightmark}}
\fancyfoot[C]{}


\usepackage{tikz}
\usepackage{csquotes}
\definecolor{hellgruen}{rgb}{0.75,0.75,0.75}
\usepackage{subcaption}
\usepackage{graphicx}
\usepackage{caption}

\begin{document}

%------------------------------------------------
% Titelseite
%------------------------------------------------

\begin{titlepage}
\vspace*{-2cm}
\newlength{\links}
\setlength{\links}{-1.5cm} \sf \LARGE

\hspace*{\links}
\begin{minipage}{12.5cm}
\includegraphics[width=8cm]{tud_logo_rgb}
\end{minipage}

\vspace*{4cm}

\large
\begin{center}
{\Large Seminarausarbeitung} \\[1ex]
{\LARGE\textbf{Darwin's Avatars}}\\[3ex]
Marian Kleineberg, Christopher Riesner\\[1ex]
\today\\[7ex]
im Rahmen des Proseminars\\[1ex]
{\Large\textbf{Computational Intelligence in Spielen}}\\[1ex]
von Dr.~Igor Vatolkin\\[1ex]
Wintersemester 2016/17
\end{center}

\vspace*{5cm}
\hspace*{\links}
\begin{minipage}[b]{15cm}
\normalsize \raggedright

\textbf{Basierend auf:}\\
D.Lessin, S.Risi, Darwin's Avatars: a Novel Combination of Gameplay and Procedural Content Generation, GECCO '15, July 11 - 16
\end{minipage}

\definecolor{TUGreen}{rgb}{0.517,0.721,0.094}
\vfill
\hspace*{\links}
\begin{minipage}[b]{8cm}
\normalsize \raggedright
Fakultät für Informatik\\
Lehrstuhl für Algorithm Engineering (Ls11)\\
Technische Universität Dortmund\\
\url{http://ls11-www.cs.tu-dortmund.de}
\end{minipage}

\end{titlepage}

%------------------------------------------------
% Inhaltsverzeichnis
%------------------------------------------------

\tableofcontents
\clearpage


%------------------------------------------------
% Einführung
%------------------------------------------------

\section{Einführung}

In dieser Ausarbeitung wird ein Spiel betrachtet, in dem es darum geht für den Spieler fremde Kreaturen 
zu steuern. Damit der Spieler stets für ihn unbekannte Kreaturen kontrollieren kann wird eine Methode benötigt, mit der neue Kreaturen erzeugt werden können. Dies wird ermöglicht durch die prozedurale Generierung solcher Kreaturen. Dazu wird ein evolutionärer Algorithmus verwendet. Durch die Vielfalt der daraus resultierenden Kreaturen entsteht ein langfristiger Spielspaß.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{img/darwin.png}
	\caption{Screenshot aus dem Spiel, wer zuerst das Ende der Strecke erreicht, gewinnt}
\end{figure}


Darüber hinaus wird im evolutionären Algorithmus ein neuronales Netz entwickelt, welches einer KI die
Steuerung der Kreatur ermöglicht. Es ergibt sich die Möglichkeit gegen eine KI, oder gegen einen weiteren menschlichen Spieler anzutreten.

Der evolutionäre Algorithmus entstammt einer früheren Arbeit von Lessin \cite{LeFuMi13}. Er berechnet für jede Kreatur einen Fitnesswert, der ihre Bewegungsgeschwindigkeit und Ästhetik bewertet. Über mehrere hundert Generationen werden die Kreaturen mit dem höchsten Fitnesswert selektiert und durch Paarung oder Mutation neue Kreaturen generiert.



\section{Kodierung}

Die Kreaturen benötigen nun einen Bauplan der sie spezifiziert. Dieser sei im Folgenden \textsc{Genotyp} benannt. Analog zu dem Begriff aus der Biologie speichert der Genotyp die Daten über die Kreatur. Zu den Daten gehört neben Struktur und Muskeln auch komplexere Informationen wie die Art der Verbindung zweier Segmente zueinander. Wie bei den Lebewesen brauchen die Knochen, in dem Fall die Körpersegmente Gelenke um eine bestimmte Bewegungsart auszuführen. Es eignen sich dafür verschiedene Gelenktypen. So können die Gelenke starr, hebelähnlich, verdreht, oder kugelförmig ausfallen. Der Parameter \textsc{Gelenkfreiheit} bestimmt den Grad bis zu dem sich das Gelenk bewegen lässt. Die Gelenke werden mit Muskeln bespannt, um Bewegung überhaupt erst zu ermöglichen. Gespeichert werden die Daten in einem Graphen wie in Abbildung \ref{fig:genotyp}. Gleich unter dem jeweiligen Graphen ist die zugehörige Kreatur abgebildet. Sie wird durch den \textsc{Phänotypen} beschrieben. Die Graphen (a) und (b) führen zur gleichen Kreatur. Das erklärt sich dadurch, dass Graph (a) redundante Informationen enthält. Die Kreatur besteht zwar aus drei Körpersegmenten, aber nur aus zwei verschiedenen Körpersegmenttypen. Es genügt also zu speichern, dass das eine Segment mit zwei anderen gleichartigen Segmenten verbunden ist. Die Graphen (c) und (d) formen komplexere Kreaturen. Dazu wird die Eigenschaft reflexiver Kanten ausgenutzt. Diese Kanten bilden auf ein gleichartiges Körpersegment ab. Oft ist das eine gewünschte Eigenschaft wie bei den Flügeln der Kreatur (c), oder den Gliedmaßen von Figur (d). Damit der Phänotyp eindeutig ist wird an dieser Stelle ein weiterer Parameter benötigt. Die reflexiven Kanten können beliebig oft verfolgt werden. Damit ist eine endlose Rekursion möglich. Da unendlich große Kreaturen am Computer nicht dargestellt werden können wird durch das Setzen eines \textsc{rekursiven Limits} die Anzahl der Körpersegmente beschränkt. 

\begin{figure}[H]
		\resizebox{0.3\textwidth}{!}{
		\begin{tikzpicture}[->,shorten >=1pt,auto,node distance=0.7cm,main 				  node/.style={circle,draw,font=\sffamily\Large\bfseries}]

		\node[main node] (1) {};
		\node[main node] (2) [below left of = 1] {};
		\node[main node] (3) [below right of = 1] {};

		\path[every node/.style={font=\sffamily\small}]
		(1) edge [bend right] node[left] {} (2)
		edge [bend left] node[left] {} (3)			
		;
		\end{tikzpicture}
		\small(a)
	}
		\resizebox{0.2\textwidth}{!}{
			\begin{tikzpicture}[->,shorten >=1pt,auto,node distance=0.85cm,main node/.style={circle,draw,font=\sffamily\Large\bfseries}]
			
			\node[main node] (1) {};
			\node[main node] (2) [below of = 1] {};
			
			\path[every node/.style={font=\sffamily\small}]
			(1) edge [bend right = 20] node[left] {} (2)
			edge [bend left = 20] node[left] {} (2)			
			;
			\end{tikzpicture}
			\small(b)
		}
	\resizebox{0.2\textwidth}{!}{
		\begin{tikzpicture}[->,shorten >=1pt,auto,node distance=1cm,main node/.style={circle,draw,font=\sffamily\Large\bfseries}]
		
		\node[main node] (1) {};
		\node[main node] (2) [below of = 1] {};
		
		\draw (1) to [out=60,in=120,looseness=8, min distance=0.5cm] (1);
		\draw (2) to [out=300,in=240,looseness=8, min distance=0.5cm] (2);
		
		\path[every node/.style={font=\sffamily\small}]
		(1) edge [bend right = 20] node[left] {} (2)
		edge [bend left = 20] node[left] {} (2)			
		;
		\end{tikzpicture}
		\small(c)
	}
		\resizebox{0.2\textwidth}{!}{
			\begin{tikzpicture}[->,shorten >=1pt,auto,node distance=0.8cm,main node/.style={circle,draw,font=\sffamily\Large\bfseries}]
			
			\node[main node] (1) {};
			\node[main node] (2) [below of = 1] {};
			\node[main node] (3) [above of = 1] {};
			
			\draw (2) to [out=300,in=240,looseness=8, min distance=0.5cm] (2);
			
			\draw (1) to [] (3);
			
			\path[every node/.style={font=\sffamily\small}]
			(1) edge [bend right = 10] node[left] {} (2)
			edge [bend left = 10] node[left] {} (2)
			edge [bend right = 30] node[left] {} (2)
			edge [bend left = 30] node[left] {} (2)
			;
			\end{tikzpicture}
			\small(d)
		}
		\resizebox{0.24\textwidth}{!}{
		\includegraphics[width=0.25\textwidth]{img/1.png}
	}
		\resizebox{0.24\textwidth}{!}{
		\includegraphics[width=0.25\textwidth]{img/1.png}
	}
		\resizebox{0.24\textwidth}{!}{
		\includegraphics[width=0.25\textwidth]{img/4.png}
	}
		\resizebox{0.24\textwidth}{!}{
		\includegraphics[width=0.25\textwidth]{img/5.png}
	}
	\label{fig:genotyp}
\caption{Der Genotyp als Graph: Die Körpersegmente werden durch Knoten dargestellt, die Kanten visualisieren die Beziehungen zueinander.}
\end{figure}

\section{Kontrolle mit neuronalen Netzen}

Das Ergebnis der Kodierung ist eine Kreatur wie sie im Spiel gesteuert werden kann. Der Genotyp wird jetzt um ein neuronales Netz erweitert. Dieses neuronale Netz ermöglicht es die Kreatur durch eine KI zu steuern. Dafür werden mehrere Komponenten benötigt. 

\subsection{Neuronen}

\textsc{Neuronen} führen arithmetische, oder logische Operationen auf ein Eingangssignal aus und geben es anschließend an ihrem Ausgang zurück. Im Graphen werden die Neuronen als Knoten dargestellt. Sie arbeiten dabei im Wertebereich [0,1]. Mögliche Funktionen sind: Summe, Produkt, Division, Minimum aus Summe und 1, Größer als, 
Minimum, Maximum, Wenn dann, Interpolieren, Sin, Cosin, Arctan, Logarithmus, Exponent,
Integrieren, Differenzieren, Glätten, Speichern, Oszilloskop und sägeförmiges Oszilloskop. Wie die Neuronen mit konkreten Werten arbeiten ist in Abbildung \ref{fig:neuronen} ersichtlich. Der Sinus errechnet einen vom Zeitparamater t abhängigen Wert aus der Sinusfunktion. Das Komplement dreht den eingehenden Wert um. aus x wird 1 - x. Dieser Parameter wird allerdings nicht als Eingangssignal gegeben, er kommt vom System.

\begin{figure}[H]
	\resizebox{0.24\textwidth}{!}{
		\begin{tikzpicture}[shorten >=1pt,node distance=1.5cm,thick] 
		\node[circle,draw] (1) {wav};
		\coordinate [right of=1] (h1);
		\coordinate [left of=1] (h2);
		\coordinate [above of=h2] (h3);
		\coordinate [below of=h2] (h4);
		\draw [->] (1) to[] node[align=center] {\tiny $\sin(t)$\\} (h1);
		\draw [->, opacity=0] (h2) to[] node[auto] {} (1); 
		\draw [->, opacity=0] (h3) to[] node[auto] {} (1);
		\draw [->, opacity=0] (h4) to[] node[auto] {} (1);			
		\end{tikzpicture}
	}
	\resizebox{0.24\textwidth}{!}{
		\begin{tikzpicture}[shorten >=1pt,node distance=1.5cm,thick] 
		\node[circle,draw] (1) {com};
		\coordinate [right of=1] (h1);
		\coordinate [left of=1] (h2);
		\coordinate [above of=h2] (h3);
		\coordinate [below of=h2] (h4);
		\draw [->] (1) to[] node[align=center] {\tiny 0.147 \\ } (h1);
		\draw [->] (h2) to[] node[auto] {\tiny 0.853} (1);
		\draw [->, opacity=0] (h3) to[] node[auto] {} (1);
		\draw [->, opacity=0] (h4) to[] node[auto] {} (1); 			
		\end{tikzpicture}
	}
	\resizebox{0.24\textwidth}{!}{
		\begin{tikzpicture}[shorten >=1pt,node distance=1.5cm,thick] 
		\node[circle,draw] (1) {max};
		\coordinate [right of=1] (h1);
		\coordinate [left of=1] (h2);
		\coordinate [above of=h2] (h3);
		\coordinate [below of=h2] (h4);
		\draw [->] (1) to[] node[align=center] {\tiny 0.628 \\ } (h1);
		\draw [->] (h2) to[] node[auto] {\tiny 0.628} (1);
		\draw [->] (h3) to[] node[auto] {\tiny 0.254} (1);
		\draw [->, opacity=0] (h4) to[] node[auto] {} (1); 			
		\end{tikzpicture}
	}
	\resizebox{0.24\textwidth}{!}{
		\begin{tikzpicture}[shorten >=1pt,node distance=1.5cm,thick] 
		\node[circle,draw] (1) {+};
		\coordinate [right of=1] (h1);
		\coordinate [left of=1] (h2);
		\coordinate [above of=h2] (h3);
		\coordinate [below of=h2] (h4);
		\draw [->] (1) to[] node[align=center] {\tiny 0.535 \\ } (h1);
		\draw [->] (h2) to[] node[auto] {\tiny 0.1} (1);
		\draw [->] (h3) to[] node[auto] {\tiny 0.435} (1);
		\draw [->] (h4) to[] node[auto] {\tiny 0} (1); 			
		\end{tikzpicture}
	}
	\label{fig:neuronen}
	\caption{Neuronen mit verschiedenem Eingangsgrad. Sinus, Komplement, Maximum und das Minimum aus 1 und Summe}
\end{figure}

\subsection{Sensoren}

Das Eingangssignal kommt von einem weiteren wesentlichen Bestandteil des neuronalen Netz, den \textsc{Sensoren}. Jeder Muskel einer Kreatur besitzt einen Sensor, der die aktuelle Länge des Muskels misst. Dieser Wert variiert je nachdem, ob er gestreckt, oder zusammengezogen ist. Denkbar wären auch andere Sensoren. Sims \cite{Sims94} erweiterte die Kreaturen um Photosensoren, die es der Kreatur ermöglichen, sich auf eine Lichtquelle zu zubewegen. Auch Kontaktsensoren bieten sich an. In dem Spiel wird sich auf Sensoren beschränkt, die die Länge des Muskels messen.

\subsection{Effektoren}

Die Neuronen berechnen in Abhängigkeit von der Länge der Muskeln einen Wert. Dieser Wert landet bei den \textsc{Effektoren}. Wie auch die Sensoren gehören die Effektoren zu den Muskeln. Die Effektoren spannen in Abhängigkeit vom berechneten Wert den Muskel an, oder entspannen ihn. Durch diesen Kreislauf wird der Kreatur eine flüssige Bewegung ermöglicht. Die Sensoren und die Effektoren werden im Genotyp wie die Neuronen als Knoten dargestellt.

\subsection{Grapherweiterung}

Mit den Bestandteilen ist das neuronale Netz komplett und es lässt sich zusammengefügt im Genotyp einsetzen. Abbildung  \ref{fig:extendedgraph} zeigt einen solchen Genotypen. Die fetten Knoten beschreiben wie in den vorherigen Beispielen die Körpersegmente. J0 und J1 generieren je einen Wert, der durch verschiedene Neuronen reist und zum Schluss in den Effektoren ankommt. Neben den fetten Knoten gibt es in diesem Genotypen auch einen durch eine gestrichelte Linie markierten Knoten. Dieser enthält nur Neuronen die für die Kreatur genau ein einziges Mal zur Kontrolle benötigt werden. Denn dieser Knoten ist unabhängig vom gewählten Parameter des rekursiven Limits. Die Sensoren und Effektoren der Muskeln sind zudem bloß in einem Segment eingetragen, obwohl sie zwei Körpersegmente verbinden. Sie dienen im Graph jedoch nur als Quelle und Ziel eines Signals, es ist nicht notwendig sie doppelt aufzuführen. Bei der Wahl vom rekursiven Limit gleich zwei und dem 

\begin{figure}[H]
	\resizebox{0.55\textwidth}{!}{
	\includegraphics[width=0.9\textwidth]{img/evolved_graph.png}
	}
	\resizebox{0.45\textwidth}{!}{
	\includegraphics[width=0.9\textwidth]{img/6.png}
	}
	\label{fig:extendedgraph}
	\caption{Genotyp mit Sensoren J0, J1 und Effektoren E0, E1 und der zugehörige Phänotyp}
\end{figure}

\section{Evolutionäre Generierung}

EVKs werden mithilfe eines evolutionären Algorithmus generiert.
Bei einem evolutionären Algorithmus werden nach dem Vorbild der Evolution in der Natur Entitäten, in diesem Fall EVKs, bezüglich einer Fitnessfunktion optimiert.
Das Verfahren soll Entitäten von besonders hoher Fitness produzieren.
In \textsc{Darwin's Avatars} ist die Fitness die Laufgeschwindigkeit der Kreaturen.
Dabei ist besonders wichtig, dass die Fitnessfunktion mit dem Spielziel übereinstimmt.
Zusätzlich zur Laufgeschwindigkeit werden für die Fitness ästhetische Eigenschaften berücksichtigt. 

\subsection{Evolutionärer Algorithmus}
Zunächst wird ein eine Population von zufälligen Kreaturen generiert.
Alle Eigenschaften der Kreaturen werden zufällig gesetzt, dazu gehören der Graph der Körperteile, die Muskeln und das neuronale Netz.
Die in der Arbeit verwendete Populationsgröße ist $500$.

Nun wird in jeder Generation der Fitnesswert für jede Kreatur bestimmt.
Dazu wird die Kreatur in der Physikengine \textsc{PhysX} simuliert und die Laufgeschwindigkeit gemessen.
Dieser Teil des Verfahrens ist besonders rechenaufwändig.
Nun wird ein Teil der Population, $80\%$, verworfen.
Die Population wird mit Mutationen und Nachkommen der verbleibenden Kreaturen auf ihre ursprüngliche Größe aufgefüllt.

Dieser Schritt wird je nach verfügbarer Rechenzeit solange wiederholt, bis die Fitness der besten Kreaturen gut genug ist.
In dieser Arbeit werden $500$ Generationen berechnet.

\subsection{Mutation}
Die Mutation ist die zufällige Veränderung einer bestehenden Kreatur.
Das Verfahren ist ähnlich zu der zufälligen Generierung einer neuen Kreatur, allerdings werden Werte bevorzugt, die nahe an denen der bestehenden Kreatur sind.
Eine zufällige Auswahl der Eigenschaften der Kreatur wird geändert.
Abhängig des Datentyps wird mit den Eigenschaften wie folgt verfahren:
Booleans werden negiert. Kontinuierliche Werte werden zufällig verschoben. Der Wert der Änderung ist dabei Gauß-verteilt, kleine Änderungen sind häufiger als große.
Diskrete Werte werden zufällig neu gesetzt.
Im neuronalen Netz und im Graphen der Körperteile werden Knoten und Kanten zufällig hinzugefügt und entfernt.

\subsection{Paarung}
Bei der Paarung werden zur Generierung einer neuen Kreatur zwei bestehende Kreaturen, die Eltern, berücksichtigt.
Im Folgenden werden zwei Verfahren zur Paarung beschrieben, die in \textsc{Darwin's Avatars} Verwendung finden.

In beiden Fällen wird der Graph der Kreatur zunächst in eine lineare Form gebracht.
Die Menge Knoten wird als Liste aufgefasst.
Die Ziele der Kanten werden durch ihre relative Position gespeichert.
Eine Kante mit dem Wert $+2$ zeigt auf den Knoten, der in der Liste der zweite Nachfolger des Ausgangsknotens ist.

\begin{figure}
	\begin{center}
		\resizebox{0.48\textwidth}{!}{
			\begin{tikzpicture}[->,shorten >=1pt,auto,node distance=0.8cm,main node/.style={circle,draw,font=\sffamily\Large\bfseries}]
			
			\node[main node] (1) {};
			\node[main node] (2) [right of = 1] {};
			\node[main node] (3) [right of = 2] {};
			\node[main node] (4) [right of = 3] {};
			\node[main node] (5) [right of = 4] {};
			
			\path[] (1) edge [bend left = 40] node[left] {} (2);
			\path[] (1) edge [bend left = 80] node[left] {} (3);
			\path[] (3) edge [bend left = 30] node[left] {} (4);
			\path[] (3) edge [bend left = 60] node[left] {} (4);
			\path[] (4) edge [bend left = 40] node[left] {} (5);
			
			\end{tikzpicture}
		}
		\hspace{1em}
		\resizebox{0.38\textwidth}{!}{
			\begin{tikzpicture}[->,shorten >=1pt,auto,node distance=0.8cm,main node/.style={circle,draw,font=\sffamily\Large\bfseries}]
			
			\node[main node] (1) [fill = hellgruen] {};
			\node[main node] (2) [right of = 1, fill = hellgruen] {};
			\node[main node] (3) [right of = 2, fill = hellgruen] {};
			\node[main node] (4) [right of = 3, fill = hellgruen] {};
			
			\path[] (1) edge [bend left = 10] node[left] {} (2);
			\path[] (1) edge [bend left = 30] node[left] {} (2);
			\path[] (1) edge [bend left = 50] node[left] {} (2);
			\path[] (1) edge [bend left = 50] node[left] {} (2);
			\path[] (2) edge [bend left = 30] node[left] {} (3);
			\path[] (2) edge [bend left = 60] node[left] {} (4);
			
			\draw (4) to [out=110,in=70,looseness=8] (4);
			
			\end{tikzpicture}
		}
	\end{center}		
	\begin{center}
		\includegraphics[width=0.9\textwidth]{img/pfeile.png}
	\end{center}	
	\resizebox{0.46\textwidth}{!}{
		\begin{tikzpicture}[->,shorten >=1pt,auto,node distance=0.8cm,main node/.style={circle,draw,font=\sffamily\tiny\bfseries}]
		
		\node[main node] (1) {};
		\node[main node] (2) [right of = 1, fill = hellgruen] {};
		\node[main node] (3) [right of = 2] {};
		\node[main node] (4) [right of = 3, fill = hellgruen] {};
		\node[main node] (5) [right of = 4] {};
		
		\path[] (1) edge [bend left = 40] node[left] {} (2);
		\path[] (1) edge [bend left = 80] node[left] {} (3);
		\path[] (3) edge [bend left = 30] node[left] {} (4);
		\path[] (3) edge [bend left = 60] node[left] {} (4);
		
		\path[] (2) edge [bend left = 30] node[left] {} (3);
		\path[] (2) edge [bend left = 60] node[left] {} (4);
		
		\draw (4) to [out=110,in=70,looseness=8] (4);
		
		\end{tikzpicture}
	}

	\caption{Paarung durch \enquote{Kreuzung}: Der erste Elternteil wird kopiert und einzelne Knoten werden durch die Knoten des anderen Elternteils an der gleichen Position ersetzt.}
	\label{fig:paarung1}
\end{figure}

Abbildung \ref{fig:paarung1} zeigt die erste Methode zur Paarung, die \enquote{Kreuzung}.
Zunächst wird eine Kopie des einen Elternteils angelegt.
Nun wird eine zufällige Auswahl an Knoten, im Beispiel Knoten 2 und 4, durch die Knoten mit der gleichen Position des anderen Elternteils ersetzt.
Die neuen Knoten behalten ihre Kanten mit den relativen Werten, die jetzt aber ggf. auf einen anderen Knoten der gleichen relativen Position zeigen.

\begin{figure}
	\resizebox{0.48\textwidth}{!}{
		\begin{tikzpicture}[->,shorten >=1pt,auto,node distance=0.8cm,main node/.style={circle,draw,font=\sffamily\Large\bfseries}]
		
		\node[main node] (1) {};
		\node[main node] (2) [right of = 1] {};
		\node[main node] (3) [right of = 2] {};
		\node[main node] (4) [right of = 3] {};
		\node[main node] (5) [right of = 4] {};
		
		\path[] (1) edge [bend left = 40] node[left] {} (2);
		\path[] (1) edge [bend left = 80] node[left] {} (3);
		\path[] (3) edge [bend left = 30] node[left] {} (4);
		\path[] (3) edge [bend left = 60] node[left] {} (4);
		\path[] (4) edge [bend left = 40] node[left] {} (5);
		
		\end{tikzpicture}
	}
	\hspace{2.5em}
	\resizebox{0.38\textwidth}{!}{
		\begin{tikzpicture}[->,shorten >=1pt,auto,node distance=0.8cm,main node/.style={circle,draw,font=\sffamily\Large\bfseries}]
		
		\node[main node] (1) [fill = hellgruen] {};
		\node[main node] (2) [right of = 1, fill = hellgruen] {};
		\node[main node] (3) [right of = 2, fill = hellgruen] {};
		\node[main node] (4) [right of = 3, fill = hellgruen] {};
		
		\path[] (1) edge [bend left = 10] node[left] {} (2);
		\path[] (1) edge [bend left = 30] node[left] {} (2);
		\path[] (1) edge [bend left = 50] node[left] {} (2);
		\path[] (1) edge [bend left = 50] node[left] {} (2);
		\path[] (2) edge [bend left = 30] node[left] {} (3);
		\path[] (2) edge [bend left = 60] node[left] {} (4);
		
		\draw (4) to [out=110,in=70,looseness=8] (4);				
		\end{tikzpicture}
	}

	\begin{center}
	\includegraphics[width=0.7\textwidth]{img/pfeile2.png}
	\end{center}
	
	\begin{center}
	\resizebox{0.8\textwidth}{!}{
		\begin{tikzpicture}[->,shorten >=1pt,auto,node distance=0.8cm,main node/.style={circle,draw,font=\sffamily\tiny\bfseries}]
		
		\node[main node] (1) {};
		\node[main node] (2) [right of = 1] {};
		\node[main node] (3) [right of = 2] {};
		\node[main node] (4) [right of = 3] {};
		\node[main node] at (4, 0) (7) [fill = hellgruen] {};
		\node[main node] (8) [right of = 7, fill = hellgruen] {};
		\node[main node] (9) [right of = 8, fill = hellgruen] {};
		
		\path[] (1) edge [bend left = 40] node[left] {} (2);
		\path[] (1) edge [bend left = 80] node[left] {} (3);
		\path[] (3) edge [bend left = 30] node[left] {} (4);
		\path[] (3) edge [bend left = 60] node[left] {} (8);
		\path[] (7) edge [bend left = 30] node[left] {} (8);
		\path[] (7) edge [bend left = 60] node[left] {} (9);
		
		\draw (4) to [out=110,in=70,looseness=8] (4);				
		\end{tikzpicture}
	}
	\end{center}

	\caption{Paarung durch \enquote{Veredelung}: Teilketten beider Elternteile werden konkateniert und mit einer Kante verbunden.}
	\label{fig:paarung2}
\end{figure}

Abbildung \ref{fig:paarung2} zeigt die zweite Methode zur Paarung, die \enquote{Veredelung}.
Es werden von beiden Elternteil Teilketten gebildet, ein Präfix vom ersten Elternteil und ein Suffix vom zweiten.
Diese beiden Teilketten werden konkateniert.
Eine bestehende Kante der linken Teilkette wird so abgeändert, dass sie auf einen Knoten der rechten Teilkette zeigt.

Im Anschluss werden bei beiden Verfahren unerreichbare Knoten gelöscht. Kanten, die nach der Paarung auf Knoten außerhalb der Liste zeigen, werden zufällig neu gesetzt.

\subsection{Evolution in der Praxis}
Die Bestimmung der Fitnesswerte der Kreaturen in jeder Generation benötigt für jede Berechnung eine Physiksimulation der Kreatur.
Diese Simulation ist sehr rechenaufwändig und ist für lange Rechenzeiten zur Berechnung einer einzelnen Kreatur verantwortlich.
Da die einzelnen Fitnesswerte innerhalb einer Generation unabhängig voneinander sind, können sie parallel berechnet werden.
Bei besonders schlechter Fitness wird die Berechnung vorzeitig abgebrochen, um Rechenzeit zu sparen.

Rundungsfehler und Bugs in der Physikengine werden von dem evolutionären Algorithmus gefunden und ausgenutzt.
Das muss verhindert werden, da sonst Lösungen entstehen, die zwar gute Ergebnisse liefern, aber unrealistisch erscheinen und keine guten Spielgegenstände darstellen.
Das gleiche gilt für Triviallösungen, wie Fortbewegung durch Umfallen.

\section{Beispiele}
Im Folgenden werden drei Beispiele von EVKs dargestellt, die mit dem zuvor beschriebenen Verfahren entwickelt wurden.
Die Kreaturen sind in Abbildung \ref{fig:beispiele} dargestellt.

\begin{figure}
	\centering
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{img/type1.png}
		\caption{}
		\label{fig:bsp1}
	\end{subfigure}
	~
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{img/type2.png}
		\caption{}
		\label{fig:bsp2}
	\end{subfigure}
	~
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{img/type3.png}
		\caption{}
		\label{fig:bsp3}
	\end{subfigure}
	\caption{Drei evolutionäre virtuelle Kreaturen}
	\label{fig:beispiele}
\end{figure}

Die erste Kreatur \ref{fig:bsp1} besteht aus zwei Gliedmaßen und drei Muskeln.
Sie kann durch Anheben des vorderen, schwereren Blocks lange Sprünge ausführen.

Die zweite Kreatur \ref{fig:bsp2} besteht aus drei Gliedmaßen und vier Muskeln.
Aufgrund der Symmetrie besteht die Gefahr, dass die Kreatur sich rückwärts bewegt, da die Bewegung in beide Richtungen für den Mensch oder den Rechner gleich schwierig ist.
Die Kreatur springt vorwärts indem sie die beiden seitlichen Gliedmaßen anhebt.
Außerdem besteht die Gefahr des Umfallens.

Die dritte Kreatur \ref{fig:bsp3} besteht aus sieben Gliedmaßen und sechs Muskeln.
Sie führt eine langsame, vierbeinige Fortbewegung aus.

\section{Spielmechanik}
Im Spiel treten zwei Kopien der gleichen, im Vorfeld berechneten, EVK an.
Eine Kopie wird durch das evolutionär generierte neuronale Netz gesteuert.
Die andere Kopie wird durch den menschlichen Spieler gesteuert.
Das Spielziel ist, möglichst schnell das Ziel zu erreichen.
Das Spiel ist beendet, wenn beide Kreaturen das Ziel erreicht haben oder ein Zeitlimit abgelaufen ist.

Der Mensch steuert seine Kreatur mit der Tastatur.
Dabei ist jeder Muskel mit einer Taste verbunden.
Im Gegensatz zum neuronalen Netz, das den Muskel kontinuierlich steuern kann, können Muskeln durch die Tastatur nur gar nicht oder vollständig aktiviert sein.
Dies stellt einen Vorteil für den Computergegner dar, da diesem so eine genauere Kontrolle möglich ist.



%------------------------------------------------
%Beispiel für Referenzen: \cite{HanKno06} (Zeitschriftenartikel) und \cite{TarekEtAl07} (Konferenzartikel).
%------------------------------------------------

%------------------------------------------------
% Literaturverzeichnis
%------------------------------------------------

\bibliographystyle{plain}
\bibliography{literatur}
\addcontentsline{toc}{section}{\bibname}


\end{document}
